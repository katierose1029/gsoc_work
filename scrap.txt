from mpl traits file scrap 



"""matplotlib.axes.Axes
"""
# class AxesTrait(TypeCast):
#
#     allow_none = True
#     default_value = None
#     klass = matplotlib.axes.Axes
#
#     def validate(self, obj, value):
#         value = super(Axes, self).validate(obj, value)
#         if value not in (getattr(obj, self.name), None):
#             raise ValueError("Can not reset the axes. You are "
#                 "probably trying to re-use an artist in more "
#                 "than one Axes which is not supported.")
#         if value is not None and value is not self:
#             obj.stale_callback = _stale_axes_callback
#         return value

"""matplotlib.figure.Figure
"""
# class FigureTrait(TypeCast):
#
#     allow_none = True
#     default_value = None
#     klass = matplotlib.figure.Figure
#
#     def validate(self, obj, value):
#         value(Figure, self).validate(obj, value)
#         if value not in (getattr(obj, self.name), None):
#             raise RuntimeError("Can not put single artist in "
#                                "more than one figure")
#         if value is not None and value is not self:
#             self.pchanged()
#         self.stale = True
#         return value

# """matplotlib.axes.Axes
# """
# class AxesTrait(TypeCast):
#
#     allow_none = True
#     default_value = None
#     klass = matplotlib.axes.Axes
#
#     def validate(self, obj, value):
#         value = super(Axes, self).validate(obj, value)
#         if value not in (getattr(obj, self.name), None):
#             raise ValueError("Can not reset the axes. You are "
#                 "probably trying to re-use an artist in more "
#                 "than one Axes which is not supported.")
#         if value is not None and value is not self:
#             obj.stale_callback = _stale_axes_callback
#         return value
#
# """matplotlib.figure.Figure
# """
# class FigureTrait(TypeCast):
#
#     allow_none = True
#     default_value = None
#     klass = matplotlib.figure.Figure
#
#     def validate(self, obj, value):
#         value(Figure, self).validate(obj, value)
#         if value not in (getattr(obj, self.name), None):
#             raise RuntimeError("Can not put single artist in "
#                                "more than one figure")
#         if value is not None and value is not self:
#             self.pchanged()
#         self.stale = True
#         return value


#
# class TransformTrait(TypeCast):
#
#     allow_none = True
#     default_value = None
#     klass = matplotlib.transforms.Transform
#
#     def validate(self, obj, value):
#         value(Transform, self).validate(obj, value)
#         if value

"""BboxTrait -> will be used to create
    1. window_extent
    2. clip box
"""
# class BboxTrait(TypeCast):
#
#     allow_none = True
#     default_value = None
#     klass = matplotlib.transforms.Bbox
#
#     def validate(self, obj, value):
#         value.(Bbox, self).validate(obj, value)

# class PathTrait(TypeCast):


# class PatchTrait(TypeCast):
#
#     allow_none = True
#     default_value = None
#     klass = matplotlib.path.Path
#
#     def validate(self, obj, value)


_________________________________________________________________________________________________________________________________



# class ClipPathTrait(TraitType):
#
#
#     """
#     value[0] = matplotlib.path.Path
#     value[1] = TransformTrait: if None is input TransformTrait validation logic will return Idenity Trait which
#     is a trait
#     """
#     def validate(self, obj, value):
#         if isinstance(value, tuple):
#             if len(value)==2:
#                 if isinstance(value[0], 'matplotlib.path.Path') and isinstance(value[1], TransformTrait):
#                     path = value[0]
#                     transform = value[1]
#                     return value
#
#     def __init__(self, trait):
#         # pass
#         self.__trait = trait
#
#     def instance_init(self, obj):
#         # pass
#         self.__trait.instance_init(obj)
#
#     def class_init(self, cls, name):
#         # pass
#         self.__trait.class_init(cls, name)
#
#     # reference artist.py set_clip_path function
#     def set(self, obj, value):
#
#         #import statements
#         from matplotlib.patches import Patch, Rectangle
#         from matplotlib.path import Path
#
#         #extract values from value
#         path = value[0]
#         transform = value[1]
#
#         #used for error checking
#         success = False
#
#         if transform is None:
#             if isinstance(path, Rectangle):
#                 #we have to input a clipbox as well...
#                 self.__trait.set(obj, None)
#                 # self.clipbox = TransformedBbox(Bbox.unit(), path.get_transform())
#                 # self._clippath = None
#                 success = True
#             elif isinstance(path, Patch):
#                 self.__trait.set(obj, TransformedPatchPath(path))
#                 # self._clippath = TransformedPatchPath(path)
#                 success = True
#             elif isinstance(path, tuple):
#                 path, transform = path
#
#         if path is None:
#             self.__trait.set(obj, None)
#             # self._clippath = None
#             success = True
#         elif isinstance(path, Path):
#             self.__trait.set(obj, TransformedPath(path, transform))
#             # self._clippath = TransformedPath(path, transform)
#             success = True
#         elif isinstance(path, TransformedPatchPath) or isinstance(path, TransformedPath):
#             # self._clippath = path
#             self.__trait.set(obj, path)
#             success = True
#         # elif isinstance(path, TransformedPath):
#         #     self.__trait.set(obj, path)
#         #     # self._clippath = path
#         #     success = True
#         if not success:
#             print(type(path), type(transform))
#             raise self.error("Invalid arguments to set_clip_path")
#         # pass
#         # self.__trait.set(obj, val)
#
#     def get(self, obj, cls):
#         # pass
#         return self.__trait.get(obj, cls)
#
#     def __getattr__(self, name):
#         # pass
#         return getattr(self.__trait, name)

_________________________________________________________________________________________________________________________________

#To do: create either a clippath trait or modify the get and set functions
    #for now i have comments down for default, validate and observer decortors
    #clippath default
    # @default("clippath")
    # def _clippath_default(self):
    #     print("generating default clippath value")
    #     return None
    # #clippath validate: reference set_clip_path
    # @validate("clippath")
    # def _clippath_validate(self, proposal):
    #     print("cross validating %r" % proposal.value)
    #     from matplotlib.patches import Patch, Rectangle
    #     success = False
    #     #note sure how to go about the validation yet but taking a shot
    #     #referring to the set_clip_path function
    #
    #     #validate the TransformTrait here: Needs to be determined if it is None here
    #     #if this statement is true:
    #     if proposal.TransformTrait()
    #     if isinstance(path, Rectangle):
    #         self.clipbox = TransformedBbox(Bbox.unit(), path.get_transform())
    #         self._clippath = None
    #         success = True
    #     elif isinstance(path, Patch):
    #         self._clippath = TransformedPatchPath(path)
    #         success = True
    #     elif isinstance(path, tuple):
    #         path, transform = path
    #
    #     if path is None:
    #         self._clippath = None
    #         success = True
    #     elif isinstance(path, Path):
    #         self._clippath = TransformedPath(path, transform)
    #         success = True
    #     elif isinstance(path, TransformedPatchPath):
    #         self._clippath = path
    #         success = True
    #     elif isinstance(path, TransformedPath):
    #         self._clippath = path
    #         success = True
    #
    # # if setting the clip path is not a success
    # if not success:
    #     print(type(path), type(transform))
    #     raise TypeError("Invalid arguments to set_clip_path")